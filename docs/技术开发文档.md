# NFT捕捉游戏技术开发文档

## 1. 系统架构

### 1.1 整体架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端 (React)   │    │   后端 (Go)     │    │  区块链网络      │
│                 │    │                 │    │                 │
│ ┌─────────────┐ │    │ ┌─────────────┐ │    │ ┌─────────────┐ │
│ │ 用户界面     │ │    │ │ API服务     │ │    │ │ NFT721合约  │ │
│ │ 钱包连接     │ │◄──►│ │ 业务逻辑     │ │◄──►│ │ 铸造功能     │ │
│ │ 图层混合     │ │    │ │ 数据库操作   │ │    │ │ 转账功能     │ │
│ └─────────────┘ │    │ └─────────────┘ │    │ └─────────────┘ │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                    ┌─────────────────┐
                    │   数据存储       │
                    │                 │
                    │ ┌─────────────┐ │
                    │ │ PostgreSQL  │ │
                    │ │ Redis缓存   │ │
                    │ │ IPFS存储    │ │
                    │ └─────────────┘ │
                    └─────────────────┘
```

### 1.2 技术架构分层

#### 1.2.1 表现层 (Presentation Layer)
- **技术栈**: React 18 + TypeScript + Vite
- **状态管理**: Redux Toolkit + RTK Query
- **UI框架**: Tailwind CSS + Headless UI
- **Web3集成**: ethers.js + wagmi

#### 1.2.2 业务逻辑层 (Business Logic Layer)
- **技术栈**: Go 1.21 + Gin框架
- **依赖注入**: Wire
- **配置管理**: Viper
- **日志系统**: Zap

#### 1.2.3 数据访问层 (Data Access Layer)
- **主数据库**: PostgreSQL 15
- **缓存**: Redis 7
- **ORM**: GORM
- **连接池**: pgxpool

#### 1.2.4 区块链层 (Blockchain Layer)
- **智能合约**: Solidity 0.8.19
- **标准**: ERC-721
- **网络**: Ethereum Mainnet / Polygon
- **Go集成**: go-ethereum

## 2. 技术栈详细说明

### 2.1 前端技术栈

#### 2.1.1 核心框架
```json
{
  "react": "^18.2.0",
  "typescript": "^5.0.0",
  "vite": "^4.4.0"
}
```

#### 2.1.2 状态管理
```json
{
  "@reduxjs/toolkit": "^1.9.0",
  "react-redux": "^8.1.0"
}
```

#### 2.1.3 Web3集成
```json
{
  "ethers": "^6.7.0",
  "wagmi": "^1.4.0",
  "@rainbow-me/rainbowkit": "^1.0.0"
}
```

#### 2.1.4 UI组件
```json
{
  "tailwindcss": "^3.3.0",
  "@headlessui/react": "^1.7.0",
  "framer-motion": "^10.16.0"
}
```

### 2.2 后端技术栈

#### 2.2.1 核心框架
```go
// go.mod
module nft-capture-game

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/ethereum/go-ethereum v1.13.0
    gorm.io/gorm v1.25.4
    gorm.io/driver/postgres v1.5.2
    github.com/redis/go-redis/v9 v9.1.0
    github.com/spf13/viper v1.16.0
    go.uber.org/zap v1.25.0
)
```

#### 2.2.2 数据库相关
```go
require (
    github.com/jackc/pgx/v5 v5.4.3
    github.com/golang-migrate/migrate/v4 v4.16.2
)
```

### 2.3 智能合约技术栈

#### 2.3.1 开发框架
```json
{
  "@openzeppelin/contracts": "^4.9.0",
  "hardhat": "^2.17.0",
  "@nomiclabs/hardhat-ethers": "^2.2.0"
}
```

## 3. API设计

### 3.1 RESTful API规范

#### 3.1.1 基础路径
```
Base URL: https://api.nft-capture.com/v1
```

#### 3.1.2 认证方式
```
Authorization: Bearer <JWT_TOKEN>
X-Wallet-Address: <USER_WALLET_ADDRESS>
X-Signature: <MESSAGE_SIGNATURE>
```

### 3.2 API接口定义

#### 3.2.1 用户相关接口

**用户注册/登录**
```http
POST /auth/login
Content-Type: application/json

{
  "wallet_address": "0x742d35Cc6634C0532925a3b8D4C9db96590b5c8e",
  "signature": "0x...",
  "message": "Login to NFT Capture Game"
}

Response:
{
  "code": 200,
  "message": "success",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIs...",
    "user": {
      "id": 1,
      "wallet_address": "0x742d35Cc6634C0532925a3b8D4C9db96590b5c8e",
      "created_at": "2023-10-01T00:00:00Z"
    }
  }
}
```

**获取用户信息**
```http
GET /users/profile
Authorization: Bearer <token>

Response:
{
  "code": 200,
  "data": {
    "id": 1,
    "wallet_address": "0x742d35Cc6634C0532925a3b8D4C9db96590b5c8e",
    "total_captures": 25,
    "successful_captures": 18,
    "nft_count": 18,
    "last_capture_at": "2023-10-01T12:00:00Z"
  }
}
```

#### 3.2.2 捕捉相关接口

**执行捕捉**
```http
POST /capture
Authorization: Bearer <token>
Content-Type: application/json

{
  "wallet_address": "0x742d35Cc6634C0532925a3b8D4C9db96590b5c8e"
}

Response:
{
  "code": 200,
  "message": "capture successful",
  "data": {
    "capture_id": "cap_123456789",
    "success": true,
    "nft_data": {
      "token_id": 1001,
      "image_url": "https://ipfs.io/ipfs/QmXxx...",
      "metadata_url": "https://ipfs.io/ipfs/QmYyy...",
      "rarity": "rare",
      "attributes": [
        {"trait_type": "Background", "value": "Ocean"},
        {"trait_type": "Character", "value": "Dragon"},
        {"trait_type": "Accessory", "value": "Crown"}
      ]
    },
    "transaction_hash": "0xabc123..."
  }
}
```

**获取捕捉历史**
```http
GET /captures?page=1&limit=10
Authorization: Bearer <token>

Response:
{
  "code": 200,
  "data": {
    "captures": [
      {
        "id": "cap_123456789",
        "success": true,
        "created_at": "2023-10-01T12:00:00Z",
        "nft_token_id": 1001,
        "rarity": "rare"
      }
    ],
    "pagination": {
      "page": 1,
      "limit": 10,
      "total": 25,
      "total_pages": 3
    }
  }
}
```

#### 3.2.3 NFT相关接口

**获取用户NFT列表**
```http
GET /nfts?page=1&limit=12
Authorization: Bearer <token>

Response:
{
  "code": 200,
  "data": {
    "nfts": [
      {
        "token_id": 1001,
        "image_url": "https://ipfs.io/ipfs/QmXxx...",
        "name": "Capture #1001",
        "description": "A rare NFT captured in the game",
        "rarity": "rare",
        "attributes": [...],
        "created_at": "2023-10-01T12:00:00Z"
      }
    ],
    "pagination": {...}
  }
}
```

### 3.3 WebSocket接口

#### 3.3.1 实时通知
```javascript
// 连接WebSocket
const ws = new WebSocket('wss://api.nft-capture.com/ws');

// 监听消息
ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  switch(data.type) {
    case 'capture_result':
      // 处理捕捉结果
      break;
    case 'nft_minted':
      // 处理NFT铸造完成
      break;
  }
};
```

## 4. 数据库设计

### 4.1 数据库表结构

#### 4.1.1 用户表 (users)
```sql
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    wallet_address VARCHAR(42) UNIQUE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    last_login_at TIMESTAMP WITH TIME ZONE,
    total_captures INTEGER DEFAULT 0,
    successful_captures INTEGER DEFAULT 0
);

CREATE INDEX idx_users_wallet_address ON users(wallet_address);
```

#### 4.1.2 捕捉记录表 (captures)
```sql
CREATE TABLE captures (
    id VARCHAR(20) PRIMARY KEY,
    user_id BIGINT REFERENCES users(id),
    wallet_address VARCHAR(42) NOT NULL,
    success BOOLEAN NOT NULL,
    nft_token_id BIGINT,
    rarity VARCHAR(20),
    transaction_hash VARCHAR(66),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_captures_user_id ON captures(user_id);
CREATE INDEX idx_captures_created_at ON captures(created_at);
```

#### 4.1.3 NFT表 (nfts)
```sql
CREATE TABLE nfts (
    token_id BIGINT PRIMARY KEY,
    user_id BIGINT REFERENCES users(id),
    wallet_address VARCHAR(42) NOT NULL,
    capture_id VARCHAR(20) REFERENCES captures(id),
    name VARCHAR(100) NOT NULL,
    description TEXT,
    image_url TEXT NOT NULL,
    metadata_url TEXT NOT NULL,
    rarity VARCHAR(20) NOT NULL,
    attributes JSONB,
    transaction_hash VARCHAR(66),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_nfts_user_id ON nfts(user_id);
CREATE INDEX idx_nfts_rarity ON nfts(rarity);
```

#### 4.1.4 图层配置表 (layer_configs)
```sql
CREATE TABLE layer_configs (
    id BIGSERIAL PRIMARY KEY,
    layer_type VARCHAR(20) NOT NULL, -- background, character, accessory, effect
    name VARCHAR(50) NOT NULL,
    image_path TEXT NOT NULL,
    rarity_weight INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_layer_configs_type ON layer_configs(layer_type);
```

### 4.2 Redis缓存设计

#### 4.2.1 缓存键命名规范
```
user:profile:{wallet_address}     # 用户信息缓存
user:captures:{user_id}           # 用户捕捉历史缓存
capture:cooldown:{wallet_address} # 捕捉冷却时间
nft:metadata:{token_id}           # NFT元数据缓存
layer:configs                     # 图层配置缓存
```

#### 4.2.2 缓存策略
```go
// 用户信息缓存 - 30分钟
userCacheKey := fmt.Sprintf("user:profile:%s", walletAddress)
redis.Set(userCacheKey, userData, 30*time.Minute)

// 捕捉冷却 - 5分钟
cooldownKey := fmt.Sprintf("capture:cooldown:%s", walletAddress)
redis.Set(cooldownKey, "1", 5*time.Minute)
```

## 5. 智能合约设计

### 5.1 NFT721合约

#### 5.1.1 合约接口
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract NFTCaptureGame is ERC721, ERC721URIStorage, Ownable {
    using Counters for Counters.Counter;
    
    Counters.Counter private _tokenIdCounter;
    
    // 游戏服务器地址
    address public gameServer;
    
    // NFT元数据
    struct NFTMetadata {
        string rarity;
        uint256 captureTime;
        string[] attributes;
    }
    
    mapping(uint256 => NFTMetadata) public nftMetadata;
    
    event NFTMinted(
        address indexed to,
        uint256 indexed tokenId,
        string rarity,
        string tokenURI
    );
    
    constructor(address _gameServer) ERC721("NFT Capture Game", "NCG") {
        gameServer = _gameServer;
    }
    
    modifier onlyGameServer() {
        require(msg.sender == gameServer, "Only game server can call this");
        _;
    }
    
    function mintNFT(
        address to,
        string memory tokenURI,
        string memory rarity,
        string[] memory attributes
    ) public onlyGameServer returns (uint256) {
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, tokenURI);
        
        nftMetadata[tokenId] = NFTMetadata({
            rarity: rarity,
            captureTime: block.timestamp,
            attributes: attributes
        });
        
        emit NFTMinted(to, tokenId, rarity, tokenURI);
        
        return tokenId;
    }
    
    function setGameServer(address _gameServer) public onlyOwner {
        gameServer = _gameServer;
    }
    
    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }
    
    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
    }
}
```

### 5.2 合约部署配置

#### 5.2.1 Hardhat配置
```javascript
// hardhat.config.js
require("@nomiclabs/hardhat-ethers");
require("@nomiclabs/hardhat-waffle");

module.exports = {
  solidity: "0.8.19",
  networks: {
    hardhat: {},
    polygon: {
      url: "https://polygon-rpc.com/",
      accounts: [process.env.PRIVATE_KEY]
    },
    ethereum: {
      url: "https://mainnet.infura.io/v3/YOUR_PROJECT_ID",
      accounts: [process.env.PRIVATE_KEY]
    }
  }
};
```

#### 5.2.2 部署脚本
```javascript
// scripts/deploy.js
async function main() {
  const [deployer] = await ethers.getSigners();
  
  console.log("Deploying contracts with account:", deployer.address);
  
  const NFTCaptureGame = await ethers.getContractFactory("NFTCaptureGame");
  const gameServerAddress = process.env.GAME_SERVER_ADDRESS;
  
  const nftContract = await NFTCaptureGame.deploy(gameServerAddress);
  await nftContract.deployed();
  
  console.log("NFTCaptureGame deployed to:", nftContract.address);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
```

## 6. 部署架构

### 6.1 容器化部署

#### 6.1.1 前端Dockerfile
```dockerfile
# frontend/Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

#### 6.1.2 后端Dockerfile
```dockerfile
# backend/Dockerfile
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o main ./cmd/server

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/

COPY --from=builder /app/main .
COPY --from=builder /app/configs ./configs

EXPOSE 8080
CMD ["./main"]
```

#### 6.1.3 Docker Compose
```yaml
# docker-compose.yml
version: '3.8'

services:
  frontend:
    build: ./frontend
    ports:
      - "3000:80"
    depends_on:
      - backend

  backend:
    build: ./backend
    ports:
      - "8080:8080"
    environment:
      - DB_HOST=postgres
      - REDIS_HOST=redis
    depends_on:
      - postgres
      - redis

  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: nft_capture_game
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:
```

### 6.2 生产环境部署

#### 6.2.1 Kubernetes配置
```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nft-capture-backend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nft-capture-backend
  template:
    metadata:
      labels:
        app: nft-capture-backend
    spec:
      containers:
      - name: backend
        image: nft-capture-backend:latest
        ports:
        - containerPort: 8080
        env:
        - name: DB_HOST
          value: "postgres-service"
        - name: REDIS_HOST
          value: "redis-service"
```

## 7. 监控和日志

### 7.1 应用监控

#### 7.1.1 Prometheus指标
```go
// metrics/metrics.go
var (
    captureTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "capture_total",
            Help: "Total number of captures",
        },
        []string{"success"},
    )
    
    nftMintDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "nft_mint_duration_seconds",
            Help: "Duration of NFT minting",
        },
        []string{"status"},
    )
)
```

#### 7.1.2 日志配置
```go
// logger/logger.go
func NewLogger() *zap.Logger {
    config := zap.NewProductionConfig()
    config.OutputPaths = []string{"stdout", "/var/log/app.log"}
    
    logger, _ := config.Build()
    return logger
}
```

## 8. 安全考虑

### 8.1 API安全

#### 8.1.1 JWT认证
```go
// middleware/auth.go
func JWTMiddleware() gin.HandlerFunc {
    return gin.HandlerFunc(func(c *gin.Context) {
        token := c.GetHeader("Authorization")
        if token == "" {
            c.JSON(401, gin.H{"error": "Missing token"})
            c.Abort()
            return
        }
        
        // 验证JWT token
        claims, err := validateJWT(token)
        if err != nil {
            c.JSON(401, gin.H{"error": "Invalid token"})
            c.Abort()
            return
        }
        
        c.Set("user_id", claims.UserID)
        c.Next()
    })
}
```

#### 8.1.2 速率限制
```go
// middleware/ratelimit.go
func RateLimitMiddleware() gin.HandlerFunc {
    limiter := rate.NewLimiter(rate.Every(time.Minute), 60)
    
    return gin.HandlerFunc(func(c *gin.Context) {
        if !limiter.Allow() {
            c.JSON(429, gin.H{"error": "Rate limit exceeded"})
            c.Abort()
            return
        }
        c.Next()
    })
}
```

### 8.2 智能合约安全

#### 8.2.1 访问控制
```solidity
modifier onlyGameServer() {
    require(msg.sender == gameServer, "Only game server can call this");
    _;
}

modifier validAddress(address _addr) {
    require(_addr != address(0), "Invalid address");
    _;
}
```

#### 8.2.2 重入攻击防护
```solidity
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract NFTCaptureGame is ERC721, ReentrancyGuard {
    function mintNFT(...) public onlyGameServer nonReentrant returns (uint256) {
        // 铸造逻辑
    }
}
```

## 9. 测试策略

### 9.1 单元测试

#### 9.1.1 Go后端测试
```go
// tests/capture_test.go
func TestCaptureSuccess(t *testing.T) {
    // 测试捕捉成功逻辑
    service := NewCaptureService()
    result, err := service.ExecuteCapture("0x123...")
    
    assert.NoError(t, err)
    assert.True(t, result.Success)
}
```

#### 9.1.2 React前端测试
```javascript
// tests/CaptureButton.test.tsx
import { render, fireEvent } from '@testing-library/react';
import CaptureButton from '../components/CaptureButton';

test('capture button click', () => {
  const mockCapture = jest.fn();
  const { getByText } = render(<CaptureButton onCapture={mockCapture} />);
  
  fireEvent.click(getByText('Capture'));
  expect(mockCapture).toHaveBeenCalled();
});
```

### 9.2 集成测试

#### 9.2.1 API集成测试
```go
// tests/integration_test.go
func TestCaptureAPI(t *testing.T) {
    router := setupRouter()
    
    w := httptest.NewRecorder()
    req, _ := http.NewRequest("POST", "/capture", nil)
    req.Header.Set("Authorization", "Bearer "+testToken)
    
    router.ServeHTTP(w, req)
    
    assert.Equal(t, 200, w.Code)
}
```

### 9.3 智能合约测试

#### 9.3.1 Hardhat测试
```javascript
// test/NFTCaptureGame.test.js
describe("NFTCaptureGame", function () {
  it("Should mint NFT successfully", async function () {
    const [owner, gameServer, user] = await ethers.getSigners();
    
    const NFTCaptureGame = await ethers.getContractFactory("NFTCaptureGame");
    const nftGame = await NFTCaptureGame.deploy(gameServer.address);
    
    await nftGame.connect(gameServer).mintNFT(
      user.address,
      "https://ipfs.io/ipfs/QmXxx",
      "rare",
      ["Background:Ocean", "Character:Dragon"]
    );
    
    expect(await nftGame.ownerOf(0)).to.equal(user.address);
  });
});
```

## 10. 性能优化

### 10.1 前端优化

#### 10.1.1 代码分割
```javascript
// 路由懒加载
const CaptureGame = lazy(() => import('./pages/CaptureGame'));
const NFTGallery = lazy(() => import('./pages/NFTGallery'));

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <Routes>
        <Route path="/" element={<CaptureGame />} />
        <Route path="/gallery" element={<NFTGallery />} />
      </Routes>
    </Suspense>
  );
}
```

#### 10.1.2 图像优化
```javascript
// 图层预加载
const preloadImages = (imagePaths) => {
  imagePaths.forEach(path => {
    const img = new Image();
    img.src = path;
  });
};
```

### 10.2 后端优化

#### 10.2.1 数据库连接池
```go
// database/connection.go
func NewDB() *gorm.DB {
    config := &gorm.Config{
        Logger: logger.Default.LogMode(logger.Info),
    }
    
    db, err := gorm.Open(postgres.New(postgres.Config{
        DSN: dsn,
        PreferSimpleProtocol: true,
    }), config)
    
    sqlDB, _ := db.DB()
    sqlDB.SetMaxIdleConns(10)
    sqlDB.SetMaxOpenConns(100)
    sqlDB.SetConnMaxLifetime(time.Hour)
    
    return db
}
```

#### 10.2.2 缓存策略
```go
// cache/strategy.go
func GetUserProfile(walletAddress string) (*User, error) {
    // 先查缓存
    cacheKey := fmt.Sprintf("user:profile:%s", walletAddress)
    if cached := redis.Get(cacheKey); cached != nil {
        return cached, nil
    }
    
    // 查数据库
    user := getUserFromDB(walletAddress)
    
    // 写入缓存
    redis.Set(cacheKey, user, 30*time.Minute)
    
    return user, nil
}
```

这份技术开发文档涵盖了NFT捕捉游戏项目的完整技术实现方案，包括系统架构、API设计、数据库设计、智能合约开发、部署策略、安全考虑、测试策略和性能优化等各个方面。